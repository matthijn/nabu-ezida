import { parseCodeBlocks, type CodeBlock } from "./parse"
import { isSingleton, getLabelKey } from "./registry"

const UUID_PLACEHOLDER_REGEX = /\[uuid-([a-zA-Z0-9_-]+)\]/g
const TRAILING_NUMBER_REGEX = /-\d+$/

const generateShortId = (): string =>
  Math.random().toString(36).substring(2, 10)

const extractPrefix = (name: string): string =>
  name.replace(TRAILING_NUMBER_REGEX, "")

const generatePrefixedId = (name: string): string =>
  `${extractPrefix(name)}_${generateShortId()}`

const extractTypePrefix = (language: string): string =>
  language.replace(/^json-/, "")

export type GeneratedId = {
  id: string
  type: string
  label: string | null
  source: string  // placeholder key like "uuid-callout-1" or "none"
}

export type UuidMapping = Record<string, string>

export const replaceUuidPlaceholders = (content: string): { result: string; generated: UuidMapping } => {
  const generated: UuidMapping = {}

  const result = content.replace(UUID_PLACEHOLDER_REGEX, (_, name) => {
    if (!(name in generated)) {
      generated[name] = generatePrefixedId(name)
    }
    return generated[name]
  })

  return { result, generated }
}

const tryParseJson = (content: string): Record<string, unknown> | null => {
  try {
    return JSON.parse(content)
  } catch {
    return null
  }
}

const isMissingId = (id: unknown): boolean =>
  id === undefined || id === null || id === ""

const getBlockLabel = (parsed: Record<string, unknown>, language: string): string | null => {
  const labelKey = getLabelKey(language)
  if (!labelKey) return null
  const value = parsed[labelKey]
  if (typeof value !== "string") return null
  return value.length > 40 ? value.slice(0, 40) + "..." : value
}

type BlockNeedingId = {
  block: CodeBlock
  parsed: Record<string, unknown>
}

const findBlocksNeedingIds = (markdown: string): BlockNeedingId[] => {
  const blocks = parseCodeBlocks(markdown)
  const result: BlockNeedingId[] = []

  for (const block of blocks) {
    if (!block.language.startsWith("json-")) continue
    if (isSingleton(block.language)) continue

    const parsed = tryParseJson(block.content)
    if (!parsed) continue

    if (isMissingId(parsed.id)) {
      result.push({ block, parsed })
    }
  }

  return result
}

export type FillIdsResult = {
  content: string
  generated: GeneratedId[]
}

export const fillMissingIds = (markdown: string): FillIdsResult => {
  const blocksNeedingIds = findBlocksNeedingIds(markdown)
  if (blocksNeedingIds.length === 0) {
    return { content: markdown, generated: [] }
  }

  let result = markdown
  let offset = 0
  const generated: GeneratedId[] = []

  for (const { block, parsed } of blocksNeedingIds) {
    const typePrefix = extractTypePrefix(block.language)
    const newId = `${typePrefix}_${generateShortId()}`
    const label = getBlockLabel(parsed, block.language)

    // Add id to parsed object
    const updatedParsed = { id: newId, ...parsed }
    const newContent = JSON.stringify(updatedParsed, null, 2)

    // Replace block content
    const blockStart = block.start + offset
    const blockEnd = block.end + offset
    const original = result.slice(blockStart, blockEnd)
    const replaced = original.replace(block.content, newContent)

    result = result.slice(0, blockStart) + replaced + result.slice(blockEnd)
    offset += replaced.length - original.length

    generated.push({
      id: newId,
      type: block.language,
      label,
      source: "none",
    })
  }

  return { content: result, generated }
}

export const buildGeneratedIdsList = (
  placeholderMapping: UuidMapping,
  autoGenerated: GeneratedId[],
  markdown: string
): GeneratedId[] => {
  const result: GeneratedId[] = []

  // Add placeholder-resolved IDs with context from the final markdown
  const blocks = parseCodeBlocks(markdown)
  for (const [placeholder, id] of Object.entries(placeholderMapping)) {
    const block = blocks.find((b) => {
      const parsed = tryParseJson(b.content)
      return parsed?.id === id
    })

    if (block) {
      const parsed = tryParseJson(block.content)
      result.push({
        id,
        type: block.language,
        label: parsed ? getBlockLabel(parsed, block.language) : null,
        source: placeholder,
      })
    } else {
      result.push({ id, type: "unknown", label: null, source: placeholder })
    }
  }

  // Add auto-generated IDs
  result.push(...autoGenerated)

  return result
}

export const formatGeneratedIds = (ids: GeneratedId[]): string => {
  if (ids.length === 0) return ""

  const lines = ids.map((g) => {
    const labelPart = g.label ? ` "${g.label}"` : ""
    const sourcePart = g.source === "none" ? "[none]" : `[${g.source}]`
    return `- ${g.id} for ${g.type} ${sourcePart}${labelPart}`
  })

  return `Generated IDs:\n${lines.join("\n")}`
}

export const hasUuidPlaceholders = (content: string): boolean =>
  UUID_PLACEHOLDER_REGEX.test(content)
