import { parseCodeBlocks, type CodeBlock } from "./parse"
import { getLabelKey, getIdPaths, type IdPathConfig } from "./registry"
import { tryParseJson, isObject, parsePath } from "./json"

const UUID_PLACEHOLDER_REGEX = /\[uuid-([a-zA-Z0-9_-]+)\]/g
const TRAILING_NUMBER_REGEX = /-\d+$/

const generateShortId = (): string => {
  const digit = Math.floor(Math.random() * 10).toString()
  const rest = Math.random().toString(36).substring(2, 9)
  return digit + rest
}

const extractPrefix = (name: string): string =>
  name.replace(TRAILING_NUMBER_REGEX, "")

const generatePrefixedId = (name: string): string =>
  `${extractPrefix(name)}_${generateShortId()}`

export type GeneratedId = {
  id: string
  type: string
  label: string | null
  source: string  // placeholder key like "uuid-callout-1" or "none"
}

export type UuidMapping = Record<string, string>

export const replaceUuidPlaceholders = (content: string): { result: string; generated: UuidMapping } => {
  const generated: UuidMapping = {}

  const result = content.replace(UUID_PLACEHOLDER_REGEX, (_, name) => {
    if (!(name in generated)) {
      generated[name] = generatePrefixedId(name)
    }
    return generated[name]
  })

  return { result, generated }
}

const isMissingId = (id: unknown): boolean =>
  id === undefined || id === null || id === ""

const getBlockLabel = (parsed: Record<string, unknown>, language: string): string | null => {
  const labelKey = getLabelKey(language)
  if (!labelKey) return null
  const value = parsed[labelKey]
  if (typeof value !== "string") return null
  return value.length > 40 ? value.slice(0, 40) + "..." : value
}

export type FillIdsResult = {
  content: string
  generated: GeneratedId[]
}

type BlockUpdate = {
  block: CodeBlock
  newContent: string
  ids: GeneratedId[]
}

const fillIdPath = (
  parsed: Record<string, unknown>,
  config: IdPathConfig,
  language: string
): GeneratedId[] => {
  const pathInfo = parsePath(config.path)
  if (!pathInfo) return []

  const ids: GeneratedId[] = []

  if (pathInfo.type === "root") {
    const currentValue = parsed[pathInfo.field]
    if (isMissingId(currentValue)) {
      const newId = `${config.prefix}_${generateShortId()}`
      parsed[pathInfo.field] = newId
      ids.push({
        id: newId,
        type: language,
        label: getBlockLabel(parsed, language),
        source: "none",
      })
    }
  } else {
    const arr = parsed[pathInfo.arrayField]
    if (!Array.isArray(arr)) return ids

    for (const item of arr) {
      if (!isObject(item)) continue
      if (!isMissingId(item[pathInfo.itemField])) continue

      const newId = `${config.prefix}_${generateShortId()}`
      item[pathInfo.itemField] = newId
      ids.push({
        id: newId,
        type: `${language}.${pathInfo.arrayField}`,
        label: null,
        source: "none",
      })
    }
  }

  return ids
}

const collectBlockUpdates = (markdown: string): BlockUpdate[] => {
  const blocks = parseCodeBlocks(markdown)
  const updates: BlockUpdate[] = []

  for (const block of blocks) {
    if (!block.language.startsWith("json-")) continue

    const parsed = tryParseJson(block.content)
    if (!parsed) continue

    const idPaths = getIdPaths(block.language)
    if (idPaths.length === 0) continue

    const ids: GeneratedId[] = []
    for (const config of idPaths) {
      ids.push(...fillIdPath(parsed, config, block.language))
    }

    if (ids.length > 0) {
      updates.push({
        block,
        newContent: JSON.stringify(parsed, null, 2),
        ids,
      })
    }
  }

  return updates
}

export const fillMissingIds = (markdown: string): FillIdsResult => {
  const updates = collectBlockUpdates(markdown)
  if (updates.length === 0) {
    return { content: markdown, generated: [] }
  }

  let result = markdown
  let offset = 0
  const generated: GeneratedId[] = []

  for (const { block, newContent, ids } of updates) {
    const blockStart = block.start + offset
    const blockEnd = block.end + offset
    const original = result.slice(blockStart, blockEnd)
    const replaced = original.replace(block.content, newContent)

    result = result.slice(0, blockStart) + replaced + result.slice(blockEnd)
    offset += replaced.length - original.length

    generated.push(...ids)
  }

  return { content: result, generated }
}

export const buildGeneratedIdsList = (
  placeholderMapping: UuidMapping,
  autoGenerated: GeneratedId[],
  markdown: string
): GeneratedId[] => {
  const result: GeneratedId[] = []

  // Add placeholder-resolved IDs with context from the final markdown
  const blocks = parseCodeBlocks(markdown)
  for (const [placeholder, id] of Object.entries(placeholderMapping)) {
    const block = blocks.find((b) => {
      const parsed = tryParseJson(b.content)
      return parsed?.id === id
    })

    if (block) {
      const parsed = tryParseJson(block.content)
      result.push({
        id,
        type: block.language,
        label: parsed ? getBlockLabel(parsed, block.language) : null,
        source: placeholder,
      })
    } else {
      result.push({ id, type: "unknown", label: null, source: placeholder })
    }
  }

  // Add auto-generated IDs
  result.push(...autoGenerated)

  return result
}

export const formatGeneratedIds = (ids: GeneratedId[]): string => {
  if (ids.length === 0) return ""

  const lines = ids.map((g) => {
    const labelPart = g.label ? ` "${g.label}"` : ""
    const sourcePart = g.source === "none" ? "[none]" : `[${g.source}]`
    return `- ${g.id} for ${g.type} ${sourcePart}${labelPart}`
  })

  return `Generated IDs:\n${lines.join("\n")}`
}

export const hasUuidPlaceholders = (content: string): boolean =>
  UUID_PLACEHOLDER_REGEX.test(content)
