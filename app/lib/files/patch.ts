import { applyDiff, generateDiff } from "~/lib/diff"
import { resolveFuzzyPatterns } from "~/lib/diff/fuzzy-inline"
import { repairJsonNewlines, toExtraPretty, fromExtraPretty, PrettyJsonError } from "~/lib/json"
import { stripPendingRefs } from "./pending-refs"
import { parseCodeBlocks } from "~/domain/blocks"
import {
  fillMissingIds,
  buildGeneratedIdsList,
  validateMarkdownBlocks,
  extractProse,
  stampActors,
  type ValidationContext,
  type ValidationError,
  type GeneratedId,
} from "~/domain/blocks"
import { getFiles } from "./store"
import { getAllCodes } from "./selectors"

export type FileResult =
  | { path: string; status: "ok"; content: string; generatedIds?: GeneratedId[] }
  | { path: string; status: "error"; error: string; blockErrors?: ValidationError[] }

export type MultiPatchResult = {
  results: FileResult[]
}

const isMdFile = (path: string): boolean => path.endsWith(".md")
const isJsonBlock = (language: string): boolean => language.startsWith("json")

const repairJsonBlocks = (markdown: string): string => {
  const blocks = parseCodeBlocks(markdown).filter((b) => isJsonBlock(b.language))
  if (blocks.length === 0) return markdown

  let result = markdown
  let offset = 0

  for (const block of blocks) {
    const repaired = repairJsonNewlines(block.content)
    if (repaired === block.content) continue

    const blockStart = block.start + offset
    const blockEnd = block.end + offset
    const original = result.slice(blockStart, blockEnd)
    const replaced = original.replace(block.content, repaired)

    result = result.slice(0, blockStart) + replaced + result.slice(blockEnd)
    offset += replaced.length - original.length
  }

  return result
}

const buildValidationContext = (markdown: string): ValidationContext => ({
  documentProse: extractProse(markdown),
  availableCodes: getAllCodes(getFiles()).map((c) => ({ id: c.id, name: c.title })),
})

const formatBlockErrors = (errors: ValidationError[]): string =>
  errors.map((e) => {
    const location = e.field ? `${e.block}.${e.field}` : e.block
    const hint = e.hint ? ` Available: ${JSON.stringify(e.hint)}` : ""
    const current = e.currentBlock ? `\nCurrent block:\n${e.currentBlock}` : ""
    return `${location}: ${e.message}${hint}${current}`
  }).join("\n")

type ApplyMdPatchOptions = {
  skipImmutableCheck?: boolean
  skipCodeValidation?: boolean
  placeholderIds?: Record<string, string>
  actor?: "ai" | "user"
}

const applyMdPatch = (path: string, content: string, patch: string, options: ApplyMdPatchOptions = {}): FileResult => {
  if (content === "" && patch === "") {
    return { path, status: "ok", content: "" }
  }

  // Resolve FUZZY[[text]] patterns before applying diff
  const { patch: resolvedPatch, unresolved } = resolveFuzzyPatterns(patch, content)
  if (unresolved.length > 0) {
    return { path, status: "error", error: `FUZZY patterns not found: ${unresolved.map(s => `"${s}"`).join(", ")}` }
  }

  const prettyContent = toExtraPretty(stripPendingRefs(content))
  const diffResult = applyDiff(prettyContent, resolvedPatch)
  if (!diffResult.ok) {
    return { path, status: "error", error: diffResult.error }
  }

  let collapsedContent: string
  try {
    collapsedContent = fromExtraPretty(diffResult.content)
  } catch (e) {
    if (e instanceof PrettyJsonError) {
      return { path, status: "error", error: e.message }
    }
    throw e
  }

  const repairedContent = repairJsonBlocks(collapsedContent)
  const { content: filledContent, generated: autoGenerated } = fillMissingIds(repairedContent)
  const stampedContent = options.actor
    ? stampActors(content, filledContent, options.actor)
    : filledContent

  const context = buildValidationContext(stampedContent)
  const validation = validateMarkdownBlocks(stampedContent, {
    context,
    original: content,
    skipImmutableCheck: options.skipImmutableCheck,
  })

  if (!validation.valid) {
    if (options.skipCodeValidation) {
      console.warn(`[patch] validation warnings for "${path}":`, formatBlockErrors(validation.errors))
    } else {
      return {
        path,
        status: "error",
        error: formatBlockErrors(validation.errors),
        blockErrors: validation.errors,
      }
    }
  }

  const generatedIds = buildGeneratedIdsList(options.placeholderIds ?? {}, autoGenerated, stampedContent)

  return {
    path,
    status: "ok",
    content: stampedContent,
    ...(generatedIds.length > 0 && { generatedIds }),
  }
}

export type ApplyFilePatchOptions = {
  skipImmutableCheck?: boolean
  skipCodeValidation?: boolean
  placeholderIds?: Record<string, string>
  actor?: "ai" | "user"
}

export const applyFilePatch = (path: string, content: string, patch: string, options: ApplyFilePatchOptions = {}): FileResult =>
  isMdFile(path)
    ? applyMdPatch(path, content, patch, options)
    : { path, status: "error", error: `only .md files allowed: ${path}` }

export type FilePatch = {
  path: string
  content: string
  patch: string
}

export const applyFilePatches = (patches: FilePatch[]): MultiPatchResult => ({
  results: patches.map(({ path, content, patch }) => applyFilePatch(path, content, patch)),
})

// Re-export for convenience
export { applyDiff as applyPatch } from "~/lib/diff"
export { generateDiff as computeJsonDiff } from "~/lib/diff"
